<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="cool blog">
    <meta name="keyword" content="null">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="favicon-w.ico">
    <link rel="alternate" type="application/atom+xml" title="WuXiaoxiao" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        【前端面试专栏】【07】HTTP｜WuXiaoxiao&#39;s blog
        
    </title>

    <link rel="canonical" href="http://xxwu.tech/2017/04/29/【前端面试专栏】【07】HTTP/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('../../../../images/bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    WuXiaoxiao
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/tags/">tags</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img" src="../../../../images/offer.png">


<style>
    
    header.intro-header {
        background-image: url('../../../../images/offer.png');
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>【前端面试专栏】【07】HTTP</h1>
                    
                    <span class="meta">
                         作者 WuXiaoxiao
                        <span>
                          日期 2017-04-29
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#前端面试专栏"
                           title="前端面试专栏">前端面试专栏</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            【前端面试专栏】【07】HTTP
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h2 id="从浏览器地址栏输入url到显示页面的步骤-以HTTP为例"><a href="#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)"></a>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</h2><ol>
<li>在浏览器地址栏输入URL</li>
<li>浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且新鲜，跳转到转码步骤如果资源未缓存，发起新请求如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。检验新鲜通常有两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>：HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>
<li>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</li>
<li>浏览器<strong>组装一个HTTP（GET）请求报文</strong></li>
<li>浏览器<strong>获取主机ip地址</strong>，过程如下：浏览器缓存本机缓存hosts文件路由器缓存ISP DNS缓存DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>
<li><strong>打开一个socket与目标IP地址，端口建立TCP链接</strong>，三次握手如下：客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包客户端发送<strong>ACK=Y+1， Seq=Z</strong></li>
<li>TCP链接建立后<strong>发送HTTP请求</strong></li>
<li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</li>
<li>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</li>
<li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li>
<li>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></li>
<li>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</strong>：主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文被动方发送<strong>ACK=X+1， Seq=Z</strong>报文被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文主动方发送<strong>ACK=Y， Seq=X</strong>报文</li>
<li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li>
<li>如果资源可缓存，<strong>进行缓存</strong></li>
<li>对响应进行<strong>解码</strong>（例如gzip压缩）</li>
<li>根据资源类型决定如何处理（假设资源为HTML文档）</li>
<li><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li>
<li><strong>构建DOM树</strong>：<strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记<strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则<strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li>
<li>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></li>
<li>构建<strong>CSSOM树</strong>：<strong>Tokenizing</strong>：字符流转换为标记流<strong>Node</strong>：根据标记创建节点<strong>CSSOM</strong>：节点创建CSSOM树</li>
<li><strong>根据DOM树和CSSOM树构建渲染树</strong>:从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code>对每一个可见节点，找到恰当的CSSOM规则并应用发布可视节点的内容和计算样式</li>
<li><strong>js解析如下</strong>：浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用document.write()</strong>，它们可以访问自己script和之前的文档元素当文档完成解析，document.readState变成interactive所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete,window触发load事件</li>
<li><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</li>
</ol>
<h2 id="GET和POST的区别，何时使用POST？"><a href="#GET和POST的区别，何时使用POST？" class="headerlink" title="GET和POST的区别，何时使用POST？"></a>GET和POST的区别，何时使用POST？</h2><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符  </p>
<p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。  </p>
<p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p>
<p>在以下情况中使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）；向服务器发送大量数据（POST 没有数据量限制）；发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠  </p>
<h2 id="XMLHttpRequest通用属性和方法"><a href="#XMLHttpRequest通用属性和方法" class="headerlink" title="XMLHttpRequest通用属性和方法"></a>XMLHttpRequest通用属性和方法</h2><ol>
<li><code>readyState</code>:表示请求状态的整数，取值：<ul>
<li>UNSENT（0）：对象已创建</li>
<li>OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求</li>
<li>HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到</li>
<li>LOADING(3)：响应体正在接收</li>
<li>DONE(4)：数据传输完成或者传输产生错误</li>
</ul>
</li>
<li><code>onreadystatechange</code>：readyState改变时调用的函数</li>
<li><code>status</code>：服务器返回的HTTP状态码（如，200， 404）</li>
<li><code>statusText</code>:服务器返回的HTTP状态信息（如，OK，No Content）</li>
<li><code>responseText</code>:作为字符串形式的来自服务器的完整响应</li>
<li><code>responseXML</code>: Document对象，表示服务器的响应解析成的XML文档</li>
<li><code>abort()</code>:取消异步HTTP请求</li>
<li><code>getAllResponseHeaders()</code>: 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行</li>
<li><code>getResponseHeader(headerName)</code>:返回headName对应的报头值</li>
<li><code>open(method, url, asynchronous [, user, password])</code>:初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证</li>
<li><code>setRequestHeader(name, value)</code>:设置HTTP报头</li>
<li><code>send(body)</code>:对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</li>
</ol>
<p>$HTML， HTTP，web综合问题</p>
<p>常见排序算法的时间复杂度,空间复杂度</p>
<p>前端需要注意哪些SEO</p>
<ol>
<li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li>
<li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li>
<li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>
<li>重要内容不要用js输出：爬虫不会执行js获取内容</li>
<li>少用iframe：搜索引擎不会抓取iframe中的内容</li>
<li>非装饰性图片必须加alt</li>
<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>
</ol>
<p>web开发中会话跟踪的方法有哪些</p>
<ol>
<li>cookie</li>
<li>session</li>
<li>url重写</li>
<li>隐藏input</li>
<li>ip地址</li>
</ol>
<p><img>的title和alt有什么区别</p>
<ol>
<li>title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。</li>
<li>alt是<img>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li>
</ol>
<p>doctype是什么,举例常见doctype及特点</p>
<ol>
<li>&lt;!doctype&gt;声明必须处于HTML文档的头部，在<html>标签之前，HTML5中不区分大小写</html></li>
<li>&lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令</li>
<li>现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</li>
<li>在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</li>
<li>HTML5不基于SGML，所以不用指定DTD</li>
</ol>
<p>常见dotype：</p>
<ol>
<li>HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a></li>
<li>HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “<a href="http://www.w3.org/TR/html4/loose.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a></li>
<li>HTML4.01 Frameset:允许表现性元素，废气元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN” “<a href="http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</a></li>
<li>XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></li>
<li>XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a></li>
<li>XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</a></li>
<li>HTML 5: &lt;!doctype html&gt;</li>
</ol>
<p>HTML全局属性(global attribute)有哪些</p>
<p>参考资料：MDN: html global attribute或者W3C HTML global-attributes</p>
<ul>
<li>accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素</li>
<li>class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素</li>
<li>contenteditable: 指定元素内容是否可编辑</li>
<li>contextmenu: 自定义鼠标右键弹出菜单内容</li>
<li>data-*: 为元素增加自定义属性</li>
<li>dir: 设置元素文本方向</li>
<li>draggable: 设置元素是否可拖拽</li>
<li>dropzone: 设置元素拖放类型： copy, move, link</li>
<li>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li>
<li>id: 元素id，文档内唯一</li>
<li>lang: 元素内容的的语言</li>
<li>spellcheck: 是否启动拼写和语法检查</li>
<li>style: 行内css样式</li>
<li>tabindex: 设置元素可以获得焦点，通过tab可以导航</li>
<li>title: 元素相关的建议信息</li>
<li>translate: 元素和子孙节点内容是否需要本地化</li>
</ul>
<p>什么是web语义化,有什么好处</p>
<p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。</p>
<p>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构</p>
<p>css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如Microformat通过添加符合规则的class描述信息</p>
<p>为什么需要语义化：</p>
<ul>
<li>去掉样式后页面呈现清晰的结构</li>
<li>盲人使用读屏器更好地阅读</li>
<li>搜索引擎更好地理解页面，有利于收录</li>
<li>便团队项目的可持续运作及维护</li>
</ul>
<p>HTTP method</p>
<ol>
<li>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可</li>
<li>GET是最常用的方法，通常用于请求服务器发送某个资源。</li>
<li>HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分</li>
<li>PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它</li>
<li>POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li>
<li>TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li>
<li>OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>
<li>DELETE请求服务器删除请求URL指定的资源</li>
</ol>
<p>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</p>
<ol>
<li>在浏览器地址栏输入URL</li>
<li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<ol>
<li>如果资源未缓存，发起新请求</li>
<li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li>
<li>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：<ul>
<li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li>
<li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>
</ul>
</li>
</ol>
</li>
<li>浏览器解析URL获取协议，主机，端口，path</li>
<li>浏览器组装一个HTTP（GET）请求报文</li>
<li>浏览器获取主机ip地址，过程如下：<ol>
<li>浏览器缓存</li>
<li>本机缓存</li>
<li>hosts文件</li>
<li>路由器缓存</li>
<li>ISP DNS缓存</li>
<li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>
</ol>
</li>
<li>打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：<ol>
<li>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口</li>
<li>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包</li>
<li>客户端发送ACK=Y+1， Seq=Z</li>
</ol>
</li>
<li>TCP链接建立后发送HTTP请求</li>
<li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</li>
<li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码</li>
<li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li>
<li>服务器将响应报文通过TCP连接发送回浏览器</li>
<li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：<ol>
<li>主动方发送Fin=1， Ack=Z， Seq= X报文</li>
<li>被动方发送ACK=X+1， Seq=Z报文</li>
<li>被动方发送Fin=1， ACK=X， Seq=Y报文</li>
<li>主动方发送ACK=Y， Seq=X报文</li>
</ol>
</li>
<li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li>
<li>如果资源可缓存，进行缓存</li>
<li>对响应进行解码（例如gzip压缩）</li>
<li>根据资源类型决定如何处理（假设资源为HTML文档）</li>
<li>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释</li>
<li>构建DOM树：<ol>
<li>Tokenizing：根据HTML规范将字符流解析为标记</li>
<li>Lexing：词法分析将标记转换为对象并定义属性和规则</li>
<li>DOM construction：根据HTML标记关系将对象组成DOM树</li>
</ol>
</li>
<li>解析过程中遇到图片、样式表、js文件，启动下载</li>
<li>构建CSSOM树：<ol>
<li>Tokenizing：字符流转换为标记流</li>
<li>Node：根据标记创建节点</li>
<li>CSSOM：节点创建CSSOM树</li>
</ol>
</li>
<li>根据DOM树和CSSOM树构建渲染树:<ol>
<li>从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none</li>
<li>对每一个可见节点，找到恰当的CSSOM规则并应用</li>
<li>发布可视节点的内容和计算样式</li>
</ol>
</li>
<li>js解析如下：<ol>
<li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading</li>
<li>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</li>
<li>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素</li>
<li>当文档完成解析，document.readState变成interactive</li>
<li>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()</li>
<li>浏览器在Document对象上触发DOMContentLoaded事件</li>
<li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件</li>
</ol>
</li>
<li>显示页面（HTML解析过程中会逐步显示页面）</li>
</ol>
<p>HTTP request报文结构是怎样的</p>
<p>rfc2616中进行了定义：</p>
<ol>
<li>首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF</li>
<li>首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束</li>
<li>请求头和消息实体之间有一个CRLF分隔</li>
<li><p>根据实际请求需要可能包含一个消息实体<br>一个请求报文例子如下：</p>
<p> GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1<br> Host: www.w3.org<br> Connection: keep-alive<br> Cache-Control: max-age=0<br> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br> User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36<br> Referer: <a href="https://www.google.com.hk/" target="_blank" rel="external">https://www.google.com.hk/</a><br> Accept-Encoding: gzip,deflate,sdch<br> Accept-Language: zh-CN,zh;q=0.8,en;q=0.6<br> Cookie: authorstyle=yes<br> If-None-Match: “2cc8-3e3073913b100”<br> If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</p>
<p> name=qiu&amp;age=25</p>
</li>
</ol>
<p>HTTP response报文结构是怎样的</p>
<p>rfc2616中进行了定义：</p>
<ol>
<li>首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF</li>
<li>首行之后是若干行响应头，包括：通用头部，响应头部，实体头部</li>
<li>响应头部和响应实体之间用一个CRLF空行分隔</li>
<li><p>最后是一个可能的消息实体<br>响应报文例子如下：</p>
<p> HTTP/1.1 200 OK<br> Date: Tue, 08 Jul 2014 05:28:43 GMT<br> Server: Apache/2<br> Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT<br> ETag: “40d7-3e3073913b100”<br> Accept-Ranges: bytes<br> Content-Length: 16599<br> Cache-Control: max-age=21600<br> Expires: Tue, 08 Jul 2014 11:28:43 GMT<br> P3P: policyref=”<a href="http://www.w3.org/2001/05/P3P/p3p.xml" target="_blank" rel="external">http://www.w3.org/2001/05/P3P/p3p.xml</a>“<br> Content-Type: text/html; charset=iso-8859-1</p>
<p> {“name”: “qiu”, “age”: 25}</p>
</li>
</ol>
<p>如何进行网站性能优化</p>
<p>雅虎Best Practices for Speeding Up Your Web Site：</p>
<ul>
<li>content方面<ol>
<li>减少HTTP请求：合并文件、CSS精灵、inline Image</li>
<li>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询</li>
<li>避免重定向：多余的中间访问</li>
<li>使Ajax可缓存</li>
<li>非必须组件延迟加载</li>
<li>未来所需组件预加载</li>
<li>减少DOM元素数量</li>
<li>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量</li>
<li>减少iframe数量</li>
<li>不要404</li>
</ol>
</li>
<li>Server方面<ol>
<li>使用CDN</li>
<li>添加Expires或者Cache-Control响应头</li>
<li>对组件使用Gzip压缩</li>
<li>配置ETag</li>
<li>Flush Buffer Early</li>
<li>Ajax使用GET进行请求</li>
<li>避免空src的img标签</li>
</ol>
</li>
<li>Cookie方面<ol>
<li>减小cookie大小</li>
<li>引入资源的域名不要包含cookie</li>
</ol>
</li>
<li>css方面<ol>
<li>将样式表放到页面顶部</li>
<li>不使用CSS表达式</li>
<li>使用<link>不使用@import</li>
<li>不使用IE的Filter</li>
</ol>
</li>
<li>Javascript方面<ol>
<li>将脚本放到页面底部</li>
<li>将javascript和css从外部引入</li>
<li>压缩javascript和css</li>
<li>删除不需要的脚本</li>
<li>减少DOM访问</li>
<li>合理设计事件监听器</li>
</ol>
</li>
<li>图片方面<ol>
<li>优化图片：根据实际颜色需要选择色深、压缩</li>
<li>优化css精灵</li>
<li>不要在HTML中拉伸图片</li>
<li>保证favicon.ico小并且可缓存</li>
</ol>
</li>
<li>移动方面<ol>
<li>保证组件小于25k</li>
<li>Pack Components into a Multipart Document</li>
</ol>
</li>
</ul>
<p>什么是渐进增强</p>
<p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下:</p>
<ul>
<li>所有浏览器都必须能访问基本内容</li>
<li>所有浏览器都必须能使用基本功能</li>
<li>所有内容都包含在语义化标签中</li>
<li>通过外部CSS提供增强的布局</li>
<li>通过非侵入式、外部javascript提供增强功能</li>
<li>end-user web browser preferences are respected</li>
</ul>
<p>HTTP状态码及其含义</p>
<p>参考RFC 2616</p>
<ul>
<li>1XX：信息状态码<ul>
<li>100 Continue：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求万仇向客户端发送一个最终响应</li>
<li>101 Switching Protocols：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。</li>
</ul>
</li>
<li>2XX：成功状态码<ul>
<li>200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回</li>
<li>201 Created：</li>
<li>202 Accepted：</li>
<li>203 Non-Authoritative Information：</li>
<li>204 No Content：</li>
<li>205 Reset Content：</li>
<li>206 Partial Content：</li>
</ul>
</li>
<li>3XX：重定向<ul>
<li>300 Multiple Choices：</li>
<li>301 Moved Permanently：</li>
<li>302 Found：</li>
<li>303 See Other：</li>
<li>304 Not Modified：</li>
<li>305 Use Proxy：</li>
<li>306 （unused）：</li>
<li>307 Temporary Redirect：</li>
</ul>
</li>
<li>4XX：客户端错误<ul>
<li>400 Bad Request:</li>
<li>401 Unauthorized:</li>
<li>402 Payment Required:</li>
<li>403 Forbidden:</li>
<li>404 Not Found:</li>
<li>405 Method Not Allowed:</li>
<li>406 Not Acceptable:</li>
<li>407 Proxy Authentication Required:</li>
<li>408 Request Timeout:</li>
<li>409 Conflict:</li>
<li>410 Gone:</li>
<li>411 Length Required:</li>
<li>412 Precondition Failed:</li>
<li>413 Request Entity Too Large:</li>
<li>414 Request-URI Too Long:</li>
<li>415 Unsupported Media Type:</li>
<li>416 Requested Range Not Satisfiable:</li>
<li>417 Expectation Failed:</li>
</ul>
</li>
<li>5XX: 服务器错误<ul>
<li>500 Internal Server Error:</li>
<li>501 Not Implemented:</li>
<li>502 Bad Gateway:</li>
<li>503 Service Unavailable:</li>
<li>504 Gateway Timeout:</li>
<li>505 HTTP Version Not Supported:</li>
</ul>
</li>
</ul>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/04/29/【前端面试专栏】【08】框架/" data-toggle="tooltip" data-placement="top"
                           title="【前端面试专栏】【08】框架">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/04/29/【前端面试专栏】【06】浏览器兼容/" data-toggle="tooltip" data-placement="top"
                           title="【前端面试专栏】【06】兼容性">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#从浏览器地址栏输入url到显示页面的步骤-以HTTP为例"><span class="toc-text">从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET和POST的区别，何时使用POST？"><span class="toc-text">GET和POST的区别，何时使用POST？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttpRequest通用属性和方法"><span class="toc-text">XMLHttpRequest通用属性和方法</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#前端面试专栏"
                           title="前端面试专栏">前端面试专栏</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>






<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/wuxiaoxiaojs">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/wuxiaoxiao2011to2015">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/anjingermeihao">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/smartdoublexiao">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; WuXiaoxiao 2017
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">您是第: <span id="busuanzi_value_site_pv"></span> 位访客</span>
                    <br>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://xxwu.tech/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-96579584-1';
    var _gaDomain = 'xxwu.tech';
    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>


<!-- Baidu Tongji -->

<script>
    var _baId = 'cd5b49144f27a7087ee7c5bf11886819';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','null','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="../../../../images/avatar.jpg">
</body>

</html>
